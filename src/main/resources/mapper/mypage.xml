<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
 "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<!-- DAO클래스를 alias설정해 뒀기에, music.mapper.mypageDao라고 작성할 필요X -->
<mapper namespace="mypage">
	<!-- resultType 속성: 쿼리 결과를 매핑할 DTO 클래스의 경로 -->

<!-- 회원 개인정보 -->
	<!-- profile : 회원정보 게시판(member) + PR게시판 Join -->
	<!-- member(userId) & prBoard(userId) => UserInfoVO클래스 객체 : id값이 같은 유저 정보 가져옴(From prBoard pr LEFT OUTER JOIN member us) -->
	<select id="findUser" resultType="userInfo">
		SELECT us.userId, us.userPw, us.userName, us.userPhone,
		us.userEmail, us.userMajor, us.userGru, us.userUpdate,

		pr.prNo, pr.prSub, pr.prText, pr.prRcount, pr.prMajor,
		pr.prLoc, pr.prCareer, pr.prVideo,
		pr.prFile, pr.prHash, pr.prUpdate,
		<!-- 회원 테이블 기준 -->
		FROM member us
		LEFT OUTER JOIN prBoard pr
		ON pr.userId = us.userId
		<!-- 입력받은 id에 해당하는 user검색 -->
		WHERE us.userId = #{id}
		<!-- 삭제되지 않은 유저 검색 -->
		AND pr.prDelYn != 'Y' AND us.userDelYn != 'Y'
	</select>


	<!-- 특정 사용자(#{id})에 대한 여러 정보 count를 조회 -->
	<select id="InfoCountById" resultType="InfoCount">
		SELECT 
			COUNT(IFNULL(appst.state, 0)) AS statusAll,
			(SELECT COUNT(IFNULL(lik.wanted_id, 0)) AS likesCount
			FROM likes lik
			WHERE lik.user_id = #{id}) AS likesCount,
			(SELECT COUNT(IFNULL(subs.company_id, 0)) AS subscribesCount
			FROM subscribes subs
			WHERE subs.user_id = #{id}) AS subscribesCount,
			(SELECT COUNT(IFNULL(req.wanted_id, 0)) AS requestsCount
			FROM requests req
			INNER JOIN resumes res ON req.resume_id = res.id
			WHERE res.user_id = #{id}) AS requestsCount
		FROM 
			application_status appst
			INNER JOIN resumes res ON appst.resume_id = res.id
		WHERE 
			res.user_id = #{id}
	</select>


<!-- 구인게시판 -->
	<!-- 인기있는 구인공고(job) List 추천 -->
	<select id="recJob" resultType="JobInfo">
		SELECT job.jobNo, job.jobCd, job.jobSpace, job.jobAddress,
		job.jobPlace, job.jobEndDate, job.jobConcert, job.jobSub,
		job.jobText, job.jobRcount,

		COUNT(CASE WHEN japp.appDelYn != 'Y' THEN 1 ELSE NULL END) AS applyCount
		<!-- COUNT(japp.appNo) AS applyCount -->
		
		FROM jobBoard job
		
		INNER JOIN jobApp japp
		ON job.jobNo = japp.jobNo

		<!-- LEFT OUTER JOIN member us
		ON job. = us.userMajor -->

		WHERE job.jobEndDate > NOW() 
		AND job.jobDelYn != 'Y' AND job.jobFin != 'Y'

	    GROUP BY 
	    job.jobNo, job.jobCd, job.jobSpace, job.jobAddress,
	    job.jobPlace, job.jobEndDate, job.jobConcert, job.jobSub,
	    job.jobText, job.jobRcount

		ORDER BY applyCount DESC
		LIMIT 4
	</select>




	<!-- 구인게시판에 글/댓글 작성 전체 목록 출력
		 구인게시판(jobBoard :job)와 구인게시판댓글(jobReply: apps)을 Join, userId로 회원 조회 -->
	<select id="findAll" resultType="music.model.StatusInfoDto">
		SELECT apps.id id, apps.wanted_id wantedId,
		apps.resume_id resumeId,
		apps.state state,
		apps.created created, wan.position_code_id
		positionCodeId,
		wan.company_id companyId, com.company_name
		companyName,
		poco.name positionCodeName,
		res.user_id userId
		
		<!-- 지원(jobReply) 테이블 기준 -->
		FROM jobReply apps
		
		<!-- 테이블 Join -->
		INNER JOIN wanteds
		wan
		ON apps.wanted_id = wan.id
		INNER JOIN companys com
		ON wan.company_id = com.id
		INNER JOIN positions_code poco
		ON wan.position_code_id = poco.id
		INNER jobApp apps
		JOIN resumes res
		ON apps.resume_id = res.id
		
		<!-- 지원테이블 유저 id = 현재 조회를 시도하는 유저의 id -->
		WHERE apps.user_id = #{id}
		
		<!-- 만일, 검색창의 키워드 값이 존재한다면, 해당 값을 활용하여 조회 -->
		<if test="keyword != null">
			AND com.company_name LIKE CONCAT('%',#{keyword},'%')
		</if>
		<!-- 해당 글을 구인글에 최근에 작성한 댓글 순으로 정렬 -->
		ORDER BY apps.jobReDate DESC
	</select>





















</mapper>